<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Dingbat Killer ‚Äî Browser Multiplayer</title>
  <style>
    :root {
      --bg: #0b0f14; --fg:#e9eef5; --muted:#94a3b8; --accent:#64d2ff; --good:#22c55e; --warn:#f59e0b; --bad:#ef4444;
      --card:#121821; --btn:#1f2937; --btn2:#0f172a;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--fg); }
    .wrap { max-width: 720px; margin: 0 auto; padding: 20px 16px 60px; }
    h1 { font-size: 24px; margin: 16px 0; }
    h2 { font-size: 18px; margin: 16px 0 8px; color: var(--accent); }
    p, label, small { color: var(--muted); }
    .card { background: var(--card); border: 1px solid #1f2937; border-radius: 14px; padding: 16px; margin: 12px 0; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    input, select { width: 100%; background: #0f172a; color: var(--fg); border: 1px solid #1f2737; border-radius: 10px; padding: 12px 12px; font-size: 16px; }
    button { appearance: none; border: 0; padding: 12px 16px; border-radius: 12px; background: var(--btn); color: var(--fg); font-size: 16px; cursor: pointer; }
    button.primary { background: var(--accent); color: #001219; font-weight: 700; }
    button.ghost { background: var(--btn2); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .center { text-align: center; }
    .pill { display: inline-block; padding: 6px 10px; border-radius: 999px; font-size: 12px; background: #0f172a; border: 1px solid #243447; }
    .good { color: var(--good); }
    .bad { color: var(--bad); }
    .warn { color: var(--warn); }
    .metric { font-size: 28px; line-height: 1.2; font-weight: 700; }
    .sub { font-size: 12px; color: var(--muted); }
    .divider { height: 1px; background: #1f2937; margin: 16px 0; }
    .sticky { position: sticky; bottom: 0; background: linear-gradient(180deg, transparent, rgba(11,15,20,0.9) 30%, rgba(11,15,20,1)); padding-top: 16px; }
    .hint { font-size: 13px; color: var(--muted); }
    .compass { width: 140px; height: 140px; border-radius: 50%; border: 2px solid #223046; margin: 8px auto; position: relative; }
    .needle { position: absolute; left: 50%; top: 50%; width: 2px; height: 52%; background: var(--accent); transform-origin: bottom center; transform: translate(-50%, -100%) rotate(0deg); }
    .northDot { position: absolute; width: 8px; height: 8px; background: var(--bad); border-radius: 50%; left: 50%; top: 4px; transform: translateX(-50%); }
    .toast { position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%); background: #111827; border: 1px solid #243447; color: var(--fg); padding: 10px 14px; border-radius: 999px; font-size: 14px; display: none; }
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
    .hold { position: relative; overflow: hidden; }
    .hold::after { content: ""; position: absolute; left: 0; top: 0; height: 100%; width: var(--hold, 0%); background: rgba(255,255,255,0.25); transition: width 0.1s linear; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üïπÔ∏è Dingbat Killer</h1>
    <p>A dead-simple multiplayer geolocation ‚Äútag‚Äù game. Create a game, join with a code, track your target, and tag them when you‚Äôre close enough.</p>

    <!-- Screens -->
    <div id="screen-welcome" class="card">
      <h2>Start</h2>
      <div class="grid-2">
        <button id="btn-new" class="primary">Create new game</button>
        <button id="btn-join" class="ghost">Join a game</button>
      </div>
      <div class="divider"></div>
      <details>
        <summary>Having trouble with location on iPhone?</summary>
        <ul class="hint">
          <li>Use Safari with <b>HTTPS</b> (e.g., GitHub Pages).</li>
          <li>Tap <b>Start tracking</b> when prompted (iOS requires a user action).</li>
          <li>Safari &rarr; aA &rarr; Website Settings &rarr; Location: <b>Allow</b>.</li>
          <li>Settings &rarr; Safari &rarr; Location: <b>While Using</b>.</li>
        </ul>
      </details>
    </div>

    <div id="screen-new" class="card" hidden>
      <h2>New game</h2>
      <div class="row">
        <label>Host name
          <input id="new-host" placeholder="e.g. Anneli" autocomplete="name" />
        </label>
      </div>
      <div class="grid-2">
        <label>Tag radius (m)
          <input id="new-radius" type="number" min="5" step="1" value="30" />
        </label>
        <label>Require hold to tag (sec)
          <input id="new-hold" type="number" min="0" step="1" value="2" />
        </label>
      </div>
      <div class="row">
        <button id="create" class="primary">Create</button>
        <button class="ghost" data-back>Back</button>
      </div>
    </div>

    <div id="screen-join" class="card" hidden>
      <h2>Join game</h2>
      <div class="grid-2">
        <label>Your name
          <input id="join-name" placeholder="e.g. Ragnar" autocomplete="name" />
        </label>
        <label>Game code
          <input id="join-code" placeholder="e.g. ABC123" class="mono" />
        </label>
      </div>
      <div class="row">
        <button id="join" class="primary">Join</button>
        <button class="ghost" data-back>Back</button>
      </div>
    </div>

    <div id="screen-lobby" class="card" hidden>
      <h2>Lobby</h2>
      <p>Share this code with your friends:</p>
      <div class="row">
        <div class="pill mono" id="lobby-code">‚Äî</div>
        <button id="copy-code">Copy</button>
      </div>
      <div class="divider"></div>
      <div id="players" class="hint">Waiting for players‚Ä¶</div>
      <div class="sticky">
        <button id="start-game" class="primary">Start game</button>
      </div>
    </div>

    <div id="screen-game" class="card" hidden>
      <h2>Hunt your target</h2>
      <div class="grid-2">
        <div class="card">
          <div class="metric" id="you-distance">‚Äî</div>
          <div class="sub">Distance to target</div>
        </div>
        <div class="card">
          <div class="metric" id="you-acc">‚Äî</div>
          <div class="sub">Your GPS accuracy</div>
        </div>
      </div>

      <div class="compass">
        <div class="northDot"></div>
        <div class="needle" id="needle"></div>
      </div>
      <div class="center hint">Rotate your phone; the needle points toward your target.</div>

      <div class="divider"></div>
      <div class="grid-2">
        <div>
          <p class="sub">You</p>
          <div class="mono" id="you-pos">‚Äî</div>
        </div>
        <div>
          <p class="sub">Target last seen</p>
          <div class="mono" id="target-pos">‚Äî</div>
        </div>
      </div>

      <div class="divider"></div>
      <div class="row">
        <button id="btn-track" class="ghost">Start tracking</button>
        <button id="btn-tag" class="hold" disabled>Hold to TAG</button>
      </div>
      <small class="hint">Tag becomes available when distance ‚â§ radius and accuracy is reasonable.</small>

      <div class="divider"></div>
      <div class="grid-2">
        <div>Radius: <span id="radius" class="pill">‚Äî</span></div>
        <div>Hold: <span id="holdsec" class="pill">‚Äî</span></div>
      </div>
    </div>

    <div id="screen-winner" class="card center" hidden>
      <h2>üèÜ Winner!</h2>
      <p>You‚Äôre the last one standing.</p>
      <button data-reset>Play again</button>
    </div>

    <div id="screen-loser" class="card center" hidden>
      <h2>üòµ Eliminated</h2>
      <p>You were tagged. Better luck next time.</p>
      <button data-reset>Play again</button>
    </div>

    <div id="screen-end" class="card center" hidden>
      <h2>Game over</h2>
      <p id="end-msg">Thanks for playing.</p>
      <button data-reset>New game</button>
    </div>

    <div class="toast" id="toast"></div>
  </div>

  <script>
  (() => {
    // ====== CONFIG (align with your backend) ======
    const API_BASE = "https://api.dingbat.se"; // <- CHANGE THIS to your server
    // Endpoints (make these match your server routes)
    const API = {
      newgame:   () => `${API_BASE}/newgame`,
      joingame:  () => `${API_BASE}/joingame`,
      start:     (gameId) => `${API_BASE}/start/${encodeURIComponent(gameId)}`,
      state:     (gameId, playerId) => `${API_BASE}/state/${encodeURIComponent(gameId)}?player=${encodeURIComponent(playerId)}`,
      update:    (gameId, playerId) => `${API_BASE}/update/${encodeURIComponent(gameId)}/${encodeURIComponent(playerId)}`,
      tag:       (gameId, playerId) => `${API_BASE}/tag/${encodeURIComponent(gameId)}/${encodeURIComponent(playerId)}`
    };

    // Expected server JSON (adjust if yours differs):
    // POST /newgame {hostName, radiusMeters, holdSeconds} -> {gameId, code, host:{playerId,name}}
    // POST /joingame {code, name} -> {gameId, player:{playerId,name}, radiusMeters, holdSeconds, started:false}
    // POST /start/:gameId -> 200
    // POST /update/:gameId/:playerId {lat,lon,acc,heading} -> 200
    // POST /tag/:gameId/:playerId {} -> {ok:true} (server checks proximity & eliminates target)
    // GET  /state/:gameId?player=PID -> {
    //   code, started, radiusMeters, holdSeconds,
    //   you:{id,name,alive:boolean,position:{lat,lon,acc,ts}},
    //   target:{id,name,position:{lat,lon,acc,ts}} | null,
    //   players:[{id,name,alive:boolean}],
    //   winner:boolean, loser:boolean, message?:string
    // }

    // ====== Small utilities ======
    const $ = sel => document.querySelector(sel);
    const show = id => document.querySelectorAll('[id^="screen-"]').forEach(x => x.hidden = x.id !== id);
    const toast = (msg, ms=2000) => { const t = $("#toast"); t.textContent = msg; t.style.display='block'; setTimeout(()=>t.style.display='none', ms); };
    const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
    const toFixed = (n, p=1)=> (isFinite(n)? n.toFixed(p) : "‚Äî");
    const degToRad = d=> d*Math.PI/180;
    const radToDeg = r=> r*180/Math.PI;
    const haversine = (a,b) => {
      const R=6371000, dLat=degToRad(b.lat-a.lat), dLon=degToRad(b.lon-a.lon);
      const s1=Math.sin(dLat/2), s2=Math.sin(dLon/2);
      const aa=s1*s1 + Math.cos(degToRad(a.lat))*Math.cos(degToRad(b.lat))*s2*s2;
      return 2*R*Math.asin(Math.sqrt(aa));
    };
    const bearing = (a,b) => {
      // initial bearing from a to b
      const œÜ1=degToRad(a.lat), œÜ2=degToRad(b.lat), Œª1=degToRad(a.lon), Œª2=degToRad(b.lon), dŒª=Œª2-Œª1;
      const y=Math.sin(dŒª)*Math.cos(œÜ2);
      const x=Math.cos(œÜ1)*Math.sin(œÜ2)-Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(dŒª);
      return (radToDeg(Math.atan2(y,x))+360)%360;
    };

    // ====== App state ======
    const state = {
      gameId:null, code:null,
      playerId:null, name:null,
      radius:30, hold:2,
      started:false,
      you:null, target:null, players:[],
      pollTimer:null, trackId:null,
      lastHeading:0
    };

    // ====== DOM refs ======
    const screens = {
      welcome: $("#screen-welcome"),
      new: $("#screen-new"),
      join: $("#screen-join"),
      lobby: $("#screen-lobby"),
      game: $("#screen-game"),
      winner: $("#screen-winner"),
      loser: $("#screen-loser"),
      end: $("#screen-end")
    };

    const els = {
      // welcome
      btnNew: $("#btn-new"),
      btnJoin: $("#btn-join"),
      // new
      newHost: $("#new-host"),
      newRadius: $("#new-radius"),
      newHold: $("#new-hold"),
      create: $("#create"),
      // join
      joinName: $("#join-name"),
      joinCode: $("#join-code"),
      joinBtn: $("#join"),
      // lobby
      lobbyCode: $("#lobby-code"),
      copyCode: $("#copy-code"),
      players: $("#players"),
      startGame: $("#start-game"),
      // game
      youPos: $("#you-pos"),
      targetPos: $("#target-pos"),
      youDist: $("#you-distance"),
      youAcc: $("#you-acc"),
      btnTrack: $("#btn-track"),
      btnTag: $("#btn-tag"),
      radius: $("#radius"),
      holdsec: $("#holdsec"),
      needle: $("#needle"),
      endMsg: $("#end-msg")
    };

    // ====== Navigation ======
    document.body.addEventListener('click', (e) => {
      const back = e.target.closest('[data-back]');
      const reset = e.target.closest('[data-reset]');
      if (back) { show('screen-welcome'); }
      if (reset) { location.reload(); }
    });

    // ====== Welcome actions ======
    els.btnNew.addEventListener('click', () => { show('screen-new'); });
    els.btnJoin.addEventListener('click', () => { show('screen-join'); });

    // ====== Create new game ======
    els.create.addEventListener('click', async () => {
      const hostName = (els.newHost.value || "").trim();
      const radiusMeters = Math.max(5, parseInt(els.newRadius.value || "30", 10));
      const holdSeconds = Math.max(0, parseInt(els.newHold.value || "2", 10));
      if (!hostName) return toast("Enter host name");
      try {
        const res = await fetch(API.newgame(), {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ hostName, radiusMeters, holdSeconds })
        });
        if (!res.ok) throw new Error("Failed to create");
        const data = await res.json();
        Object.assign(state, {
          gameId: data.gameId, code: data.code,
          playerId: data.host?.playerId, name: hostName,
          radius: data.radiusMeters ?? radiusMeters,
          hold: data.holdSeconds ?? holdSeconds,
          started: false
        });
        els.lobbyCode.textContent = state.code || "‚Äî";
        els.players.innerHTML = "<em>Waiting for players‚Ä¶</em>";
        show('screen-lobby');
        startPolling();
      } catch (err) {
        console.error(err); toast("Could not create game");
      }
    });

    // ====== Join existing game ======
    els.joinBtn.addEventListener('click', async () => {
      const name = (els.joinName.value || "").trim();
      const code = (els.joinCode.value || "").trim();
      if (!name || !code) return toast("Enter name and game code");
      try {
        const res = await fetch(API.joingame(), {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ name, code })
        });
        if (!res.ok) throw new Error("Failed to join");
        const data = await res.json();
        Object.assign(state, {
          gameId: data.gameId, code,
          playerId: data.player?.playerId, name,
          radius: data.radiusMeters ?? state.radius,
          hold: data.holdSeconds ?? state.hold,
          started: !!data.started
        });
        if (state.started) {
          prepareGameUI();
          show('screen-game');
        } else {
          els.lobbyCode.textContent = code;
          els.players.innerHTML = "<em>Waiting for host‚Ä¶</em>";
          show('screen-lobby');
        }
        startPolling();
      } catch (err) {
        console.error(err); toast("Could not join (wrong code?)");
      }
    });

    // ====== Copy code ======
    els.copyCode.addEventListener('click', async () => {
      try { await navigator.clipboard.writeText(state.code || ""); toast("Code copied"); }
      catch { toast("Copy failed"); }
    });

    // ====== Host starts the game ======
    els.startGame.addEventListener('click', async () => {
      if (!state.gameId) return;
      try {
        const res = await fetch(API.start(state.gameId), { method:'POST' });
        if (!res.ok) throw new Error("Start failed");
        state.started = true;
        prepareGameUI();
        show('screen-game');
      } catch (e) {
        console.error(e); toast("Could not start");
      }
    });

    // ====== Tracking (requires user gesture on iOS) ======
    els.btnTrack.addEventListener('click', () => {
      if (state.trackId) { stopTracking(); return; }
      startTracking();
    });

    function startTracking() {
      if (!('geolocation' in navigator)) return toast("Geolocation not supported");
      // UI
      els.btnTrack.textContent = "Stop tracking";
      els.btnTrack.classList.remove('ghost');
      // watchPosition
      const opts = { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 };
      state.trackId = navigator.geolocation.watchPosition(onPos, onPosErr, opts);
      toast("Tracking started");
    }
    function stopTracking() {
      if (state.trackId) navigator.geolocation.clearWatch(state.trackId);
      state.trackId = null;
      els.btnTrack.textContent = "Start tracking";
      els.btnTrack.classList.add('ghost');
      toast("Tracking stopped");
    }

    async function onPos(pos) {
      const { latitude:lat, longitude:lon, accuracy:acc, heading } = pos.coords;
      const head = Number.isFinite(heading) ? heading : state.lastHeading;
      state.lastHeading = head;
      // Update UI
      els.youPos.textContent = `${lat.toFixed(5)}, ${lon.toFixed(5)}  ¬±${toFixed(acc,0)}m`;
      els.youAcc.textContent = `${toFixed(acc,0)} m`;
      // Send to server (fire & forget)
      if (state.gameId && state.playerId) {
        fetch(API.update(state.gameId, state.playerId), {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ lat, lon, acc, heading: head })
        }).catch(()=>{});
      }
    }
    function onPosErr(err) {
      console.warn(err);
      toast(err.code === 1 ? "Location permission denied" : "Location error");
    }

    // ====== Poll state ======
    function startPolling() {
      stopPolling();
      poll(); // immediate
      state.pollTimer = setInterval(poll, 2000);
    }
    function stopPolling() {
      if (state.pollTimer) clearInterval(state.pollTimer);
      state.pollTimer = null;
    }
    async function poll() {
      if (!state.gameId || !state.playerId) return;
      try {
        const res = await fetch(API.state(state.gameId, state.playerId));
        if (!res.ok) throw new Error("bad state");
        const data = await res.json();
        state.started = !!data.started;
        state.radius = data.radiusMeters ?? state.radius;
        state.hold = data.holdSeconds ?? state.hold;
        state.players = data.players || [];
        state.you = data.you || null;
        state.target = data.target || null;

        if (!state.started) {
          // Lobby view
          els.players.innerHTML = state.players.map(p => `${p.alive ? 'üü¢' : 'üî¥'} ${escapeHtml(p.name)}`).join('<br/>') || "<em>Waiting‚Ä¶</em>";
          return;
        }

        // Game view
        if (screens.lobby && !screens.lobby.hidden && state.started) {
          prepareGameUI();
          show('screen-game');
        }
        updateGameUI();

        // End conditions
        if (data.winner) { stopTracking(); stopPolling(); show('screen-winner'); return; }
        if (data.loser || (data.you && data.you.alive===false)) { stopTracking(); stopPolling(); show('screen-loser'); return; }
        if (data.message) { els.endMsg.textContent = data.message; }
      } catch (e) {
        // soft-fail; keep trying
      }
    }

    function prepareGameUI() {
      els.radius.textContent = `${state.radius} m`;
      els.holdsec.textContent = `${state.hold} s`;
      els.btnTag.disabled = true;
      els.btnTag.style.setProperty('--hold','0%');
      bindHoldToTag();
    }

    function updateGameUI() {
      const you = state.you?.position;
      const tgt = state.target?.position;
      // target info
      if (tgt) {
        els.targetPos.textContent = `${tgt.lat.toFixed(5)}, ${tgt.lon.toFixed(5)}  ¬±${toFixed(tgt.acc,0)}m`;
      } else {
        els.targetPos.textContent = "‚Äî";
      }
      // distance + compass
      let dist = Infinity;
      if (you && tgt) {
        dist = haversine({lat:you.lat,lon:you.lon}, {lat:tgt.lat,lon:tgt.lon});
        const b = bearing({lat:you.lat,lon:you.lon}, {lat:tgt.lat,lon:tgt.lon});
        // Rotate needle by relative bearing (device heading vs target bearing)
        const rel = (b - (state.lastHeading||0) + 360) % 360;
        els.needle.style.transform = `translate(-50%, -100%) rotate(${rel}deg)`;
      }
      els.youDist.textContent = isFinite(dist) ? `${toFixed(dist,1)} m` : "‚Äî";
      // enable TAG if close enough & accuracy fine (< radius*1.5 heuristic)
      const acc = state.you?.position?.acc ?? Infinity;
      const ok = isFinite(dist) && dist <= state.radius && acc <= state.radius*1.5;
      els.btnTag.disabled = !ok;
      els.btnTag.title = ok ? "Hold to tag!" : "Get closer (or wait for better GPS fix)";
    }

    function bindHoldToTag() {
      let iv=null, startT=0;
      const need = Math.max(0, state.hold) * 1000;
      const setProg = (ms) => {
        const p = clamp(ms/need, 0, 1);
        els.btnTag.style.setProperty('--hold', (p*100)+'%');
      };
      const finish = async () => {
        els.btnTag.disabled = true;
        els.btnTag.style.setProperty('--hold','0%');
        try {
          const res = await fetch(API.tag(state.gameId, state.playerId), { method:'POST' });
          if (!res.ok) throw new Error("tag failed");
          toast("Tag sent!");
        } catch (e) { toast("Tag failed"); }
      };
      const clear = () => { if (iv) { clearInterval(iv); iv=null; } setProg(0); };

      const start = () => {
        if (els.btnTag.disabled) return;
        startT = Date.now();
        iv = setInterval(()=>{
          const elapsed = Date.now()-startT;
          setProg(elapsed);
          if (elapsed >= need) { clear(); finish(); }
        }, 50);
      };

      ['mousedown','touchstart'].forEach(ev=> els.btnTag.addEventListener(ev, start, {passive:true}));
      ['mouseup','mouseleave','touchend','touchcancel'].forEach(ev=> els.btnTag.addEventListener(ev, clear, {passive:true}));
    }

    // ====== Helpers ======
    function escapeHtml(s){ return (s??"").toString().replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c])); }

    // Visibility pause/resume polling (save battery)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) { stopPolling(); }
      else { startPolling(); }
    });

    // On load
    show('screen-welcome');
  })();
  </script>
</body>
</html>
